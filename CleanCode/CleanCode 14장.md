# 14장 점진적인 개선

## 결론

- 프로그램을 망치는 가장 좋은 방법은 '개선'이라는 이름으로 구조를 크게 뒤집는 행위다.
    - '개선'이라는 말에 빠져서 구조를 크게 뒤집으면, 개선 전으로 프로그램을 돌리기 어려워진다.
        - 개선을 위해 코드를 뒤집는 것이 아니라, 최소한의 코드만 건드려서 단순한 변경을 반복하며 확인하자.
    - 프로그램을 변경한 후에도 시스템은 변경 전과 똑같이 돌아가야 한다.
    - 결론은, TDD 기법을 잘 활용하자.  
    테스트 케이스가 있으면, 코드 변경 후 테스트를 돌리는 것만으로도 변경 전과 같은 기능을 하는지 쉽게 알수 있다.
- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아진다.
    - 관심사를 분리하여 코드를 이해하기 쉽게 만들자.
    - 적절한 장소를 만들어 코드를 분리하자.
- 돌아가는 프로그램을 목표로 코드를 작성하지 말자.  
    - 프로그램이 돌아가면, 코드를 정리하는 시간을 갖자.
    - 설계와 구조를 개선할 시간이 없다는건 핑계다.
        - 나쁜 일정과, 나쁜 요구사항 등은 다시 정의하면 된다.
        - 나쁜 코드보다 개발 프로젝트에 악영향을 미치는 요인은 없다.
        - 나쁜 코드는 프로그램이 커질수록 점점 늘어나 발목을 잡게된다.
- 우아한 프로그램은 한방에 뚝딱 나오지 않는다.  
    - 깨끗한 코드를 짜기 위해서는 먼저 지저분한 코드를 짠 뒤, 정리해야 한다.

5분 전에 엉망으로 만든 코드는 당장 정리하기 매우 쉽고, 아침에 만든 코드를 오후에 정리하는 것은 어렵지 않다.  
하지만, 지저분한 코드를 방치하면 서로 얽히고설켜 뒤엉키고 숨겨진 의존성이 수도 없이 생긴다. 이렇게 오래된 코드를 개선하는 것은 엄청나게 많은 비용이 든다.
### 코드는 언제나 최대한 깔끔하고 단순하게 정리하자.

---

## 점진적인 개선

출발은 좋았으나 확장성이 부족했던 모듈, **명령행 인수 구문 분석기**를 개선한 이야기를 해보자.

1차 초안은 명백한 미완성이다. (255p)

- 인스턴스 변수 개수만 해도 압도적이다.
- 'TILT'와 같은 알수없는 문자열
- HashSets, TreeSets, try-catch-catch 블럭 등의 지저분한 코드로 가독성이 떨어진다.

초안의 첫 버전을 확인해보자. (261p)

- Boolean 인수만 지원하던 초기 버전으로, 나름 괜찮은 코드다.
- 이렇게 괜찮은 코드가 왜 통제를 벗어나고, 지저분만 코드로 변해갈까?
    - 인수는 Boolean 뿐만이 아니라, Integer, String 등등 각종 타입들을 받을 수 있어야한다.
    - 그런데, 이 코드는 Boolean만을 고려해서 작성했기 때문에 다른 타입을 추가 시에 예외처리와 조건문이 추가된다.
- 어떻게 해결할 수 있을까?
    - String 인수가 추가하기 전에, 이미 추가했다면 추가한 후에, 한번 더 생각해보자. 
        - 앞으로 추가될 인수가 String밖에 없을까? Double, Integer ... 등등 수없이 많은 타입이 있는데?
    - 추가할 확률이 높다고 판단되면, 수정하자.
        - 인수 유형마다 약간씩의 차이는 있겠지만, 전체적으로 유사한 메서드를 제공하므로 부모 클래스 하나를 정의한다.  
        - 이렇게 정의된 부모 클래스는, 인수를 쉽게 추가할 수 있도록 도와준다.

클래스를 정리해보자 - String 인수 유형을 추가해보자. (272p)

- String 인수를 추가하는 과정은 boolean 인수와 매우 유사하다.
    - String 인수를 추가할 때, 일단은 부모클래스에서 모든 인수 유형을 처리하자.
        - 처음부터 분리하지 말자.
        - 각 인수 유형을 부모클래스에서 처리하도록 코드를 옮기고 테스트가 성공한뒤에 분리해도 된다.
        - 이렇게 차근차근 변경하면 구조를 조금씩 변경하는 동안헤도 시스템의 정상 동작을 유지하기 쉬워진다.

변수를 정리해보자 - 인수 유형마다 따로 만든 Map 변수를 제거하자. (281p)

- 각 인수 유형을 따로 맵으로 분리할 필요가 없어졌다.
    - 부모클래스를 정의해서 이를 상속받은 클래스들이 있으니까!
- Map 변수를 제거할때도 클래스 추가와 같은 단계를 거쳐서 변경하자.
    - 기존 Map들을 대체하기 위한 새로운 Map 변수를 생성한다.
    - 기존 Map들의 로직을 차근차근, 새로운 Map 변수로 옮긴다.
    - 전부 변경한 이후, 기존 Map 변수들을 제거한다.

조건문을 정리해보자 - 인수 유형마다 따로 만든 조건문을 정리해보자. (295p)

- 조건문을 정리하기 전에, 매개변수로 지정해야할 변수를 먼저 정리해보자.
    - 만약 멤버변수를 사용하는 로직이라면, 많은 매개변수들로 메서드가 지저분해질수도 있다.
    - 이를 먼저 정리할수 있는지 생각해보자.
- 인수 유형별 조건문에 다른 로직이 포함되어 있다면, 조건문을 분리하자.
    - 인수 유형별 조건문을 정리하는데 다른 로직이 포함되어 있다면 정리가 힘들어지므로 분리하자.
- 이제, 파생클래스들로 조건문의 로직을 조금씩 옮긴다. 

예외 클래스를 만들어보자 - 모든 예외를 하나로 모아 독자 모듈로 옮기자. (307p)

- 예외 코드와 예외 클래스들은 흉하며(?), Args 클래스에 속하지 않는다.
- 모든 예외를 모아서 ArgsException 클래스에 정의하자. 
    - ArgsException을 독자적인 모듈로 만들면 Args 모듈에서 잡다한 오류 지원 코드를 옮겨올 수 있다.
    - 이렇게 예외클래스를 정의하면, Args 모듈이 깨끗해져서 차후 확장이 쉬워진다.

---

